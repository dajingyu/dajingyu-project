import{_ as a,c as i,o as e,a2 as s}from"./chunks/framework.By8LAshg.js";const b=JSON.parse('{"title":"数据结构和算法","description":"","frontmatter":{},"headers":[],"relativePath":"自检列表/算法和环境/index.md","filePath":"自检列表/算法和环境/index.md"}'),h={name:"自检列表/算法和环境/index.md"},t=s(`<h1 id="数据结构和算法" tabindex="-1">数据结构和算法 <a class="header-anchor" href="#数据结构和算法" aria-label="Permalink to &quot;数据结构和算法&quot;">​</a></h1><p>据我了解的大部分前端对这部分知识有些欠缺，甚至抵触，但是，如果突破更高的天花板，这部分知识是必不可少的，而且我亲身经历——非常有用！ JavaScript编码能力</p><h2 id="_1-多种方式实现数组去重、扁平化、对比优缺点" tabindex="-1">1.多种方式实现数组去重、扁平化、对比优缺点 <a class="header-anchor" href="#_1-多种方式实现数组去重、扁平化、对比优缺点" aria-label="Permalink to &quot;1.多种方式实现数组去重、扁平化、对比优缺点&quot;">​</a></h2><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> arr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// indexOf + filter </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> unique</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> arr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">filter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">i</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> arr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">indexOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(e) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// set</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> arr2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arr)]</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Object.keys():利用对象的key唯一性</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">arr2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> arr){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    arr2[arr[i]] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  arr3 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Object.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">keys</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arr2)</span></span></code></pre></div><h2 id="_2-多种方式实现深拷贝、对比优缺点" tabindex="-1">2.多种方式实现深拷贝、对比优缺点 <a class="header-anchor" href="#_2-多种方式实现深拷贝、对比优缺点" aria-label="Permalink to &quot;2.多种方式实现深拷贝、对比优缺点&quot;">​</a></h2><h2 id="_3-手写函数柯里化工具函数、并理解其应用场景和优势" tabindex="-1">3.手写函数柯里化工具函数、并理解其应用场景和优势 <a class="header-anchor" href="#_3-手写函数柯里化工具函数、并理解其应用场景和优势" aria-label="Permalink to &quot;3.手写函数柯里化工具函数、并理解其应用场景和优势&quot;">​</a></h2><h2 id="_4-手写防抖和节流工具函数、并理解其内部原理和应用场景" tabindex="-1">4.手写防抖和节流工具函数、并理解其内部原理和应用场景 <a class="header-anchor" href="#_4-手写防抖和节流工具函数、并理解其内部原理和应用场景" aria-label="Permalink to &quot;4.手写防抖和节流工具函数、并理解其内部原理和应用场景&quot;">​</a></h2><ul><li>防抖：一段时间触发一次：场景：提交按钮3S提交一次</li><li>节流：在规定的时间内执行方法。场景：监视滚动条，输入实时联想</li></ul><h2 id="_5-实现一个sleep函数" tabindex="-1">5.实现一个sleep函数 <a class="header-anchor" href="#_5-实现一个sleep函数" aria-label="Permalink to &quot;5.实现一个sleep函数&quot;">​</a></h2><h1 id="手动实现前端轮子" tabindex="-1">手动实现前端轮子 <a class="header-anchor" href="#手动实现前端轮子" aria-label="Permalink to &quot;手动实现前端轮子&quot;">​</a></h1><h2 id="_1-手动实现call、apply、bind" tabindex="-1">1.手动实现call、apply、bind <a class="header-anchor" href="#_1-手动实现call、apply、bind" aria-label="Permalink to &quot;1.手动实现call、apply、bind&quot;">​</a></h2><h2 id="_2-手动实现符合promise-a-规范的promise、手动实现async-await" tabindex="-1">2.手动实现符合Promise/A+规范的Promise、手动实现async await <a class="header-anchor" href="#_2-手动实现符合promise-a-规范的promise、手动实现async-await" aria-label="Permalink to &quot;2.手动实现符合Promise/A+规范的Promise、手动实现async await&quot;">​</a></h2><h2 id="_3-手写一个eventemitter实现事件发布、订阅" tabindex="-1">3.手写一个EventEmitter实现事件发布、订阅 <a class="header-anchor" href="#_3-手写一个eventemitter实现事件发布、订阅" aria-label="Permalink to &quot;3.手写一个EventEmitter实现事件发布、订阅&quot;">​</a></h2><h2 id="_4-可以说出两种实现双向绑定的方案、可以手动实现" tabindex="-1">4.可以说出两种实现双向绑定的方案、可以手动实现 <a class="header-anchor" href="#_4-可以说出两种实现双向绑定的方案、可以手动实现" aria-label="Permalink to &quot;4.可以说出两种实现双向绑定的方案、可以手动实现&quot;">​</a></h2><h2 id="_5-手写json-stringify、json-parse" tabindex="-1">5.手写JSON.stringify、JSON.parse <a class="header-anchor" href="#_5-手写json-stringify、json-parse" aria-label="Permalink to &quot;5.手写JSON.stringify、JSON.parse&quot;">​</a></h2><h2 id="_6-手写一个模版引擎-并能解释其中原理" tabindex="-1">6.手写一个模版引擎，并能解释其中原理 <a class="header-anchor" href="#_6-手写一个模版引擎-并能解释其中原理" aria-label="Permalink to &quot;6.手写一个模版引擎，并能解释其中原理&quot;">​</a></h2><h2 id="_7-手写懒加载、下拉刷新、上拉加载、预加载等效果" tabindex="-1">7.手写懒加载、下拉刷新、上拉加载、预加载等效果 <a class="header-anchor" href="#_7-手写懒加载、下拉刷新、上拉加载、预加载等效果" aria-label="Permalink to &quot;7.手写懒加载、下拉刷新、上拉加载、预加载等效果&quot;">​</a></h2><h1 id="数据结构" tabindex="-1">数据结构 <a class="header-anchor" href="#数据结构" aria-label="Permalink to &quot;数据结构&quot;">​</a></h1><h2 id="_1-理解常见数据结构的特点-以及他们在不同场景下使用的优缺点" tabindex="-1">1.理解常见数据结构的特点，以及他们在不同场景下使用的优缺点 <a class="header-anchor" href="#_1-理解常见数据结构的特点-以及他们在不同场景下使用的优缺点" aria-label="Permalink to &quot;1.理解常见数据结构的特点，以及他们在不同场景下使用的优缺点&quot;">​</a></h2><h2 id="_2-理解数组、字符串的存储原理-并熟练应用他们解决问题" tabindex="-1">2.理解数组、字符串的存储原理，并熟练应用他们解决问题 <a class="header-anchor" href="#_2-理解数组、字符串的存储原理-并熟练应用他们解决问题" aria-label="Permalink to &quot;2.理解数组、字符串的存储原理，并熟练应用他们解决问题&quot;">​</a></h2><h2 id="_3-理解二叉树、栈、队列、哈希表的基本结构和特点-并可以应用它解决问题" tabindex="-1">3.理解二叉树、栈、队列、哈希表的基本结构和特点，并可以应用它解决问题 <a class="header-anchor" href="#_3-理解二叉树、栈、队列、哈希表的基本结构和特点-并可以应用它解决问题" aria-label="Permalink to &quot;3.理解二叉树、栈、队列、哈希表的基本结构和特点，并可以应用它解决问题&quot;">​</a></h2><h2 id="_4-了解图、堆的基本结构和使用场景" tabindex="-1">4.了解图、堆的基本结构和使用场景 <a class="header-anchor" href="#_4-了解图、堆的基本结构和使用场景" aria-label="Permalink to &quot;4.了解图、堆的基本结构和使用场景&quot;">​</a></h2><h1 id="算法" tabindex="-1">算法 <a class="header-anchor" href="#算法" aria-label="Permalink to &quot;算法&quot;">​</a></h1><h2 id="_1-可计算一个算法的时间复杂度和空间复杂度-可估计业务逻辑代码的耗时和内存消耗" tabindex="-1">1.可计算一个算法的时间复杂度和空间复杂度，可估计业务逻辑代码的耗时和内存消耗 <a class="header-anchor" href="#_1-可计算一个算法的时间复杂度和空间复杂度-可估计业务逻辑代码的耗时和内存消耗" aria-label="Permalink to &quot;1.可计算一个算法的时间复杂度和空间复杂度，可估计业务逻辑代码的耗时和内存消耗&quot;">​</a></h2><h2 id="_2-至少理解五种排序算法的实现原理、应用场景、优缺点-可快速说出时间、空间复杂度" tabindex="-1">2.至少理解五种排序算法的实现原理、应用场景、优缺点，可快速说出时间、空间复杂度 <a class="header-anchor" href="#_2-至少理解五种排序算法的实现原理、应用场景、优缺点-可快速说出时间、空间复杂度" aria-label="Permalink to &quot;2.至少理解五种排序算法的实现原理、应用场景、优缺点，可快速说出时间、空间复杂度&quot;">​</a></h2><h2 id="_3-了解递归和循环的优缺点、应用场景、并可在开发中熟练应用" tabindex="-1">3.了解递归和循环的优缺点、应用场景、并可在开发中熟练应用 <a class="header-anchor" href="#_3-了解递归和循环的优缺点、应用场景、并可在开发中熟练应用" aria-label="Permalink to &quot;3.了解递归和循环的优缺点、应用场景、并可在开发中熟练应用&quot;">​</a></h2><h2 id="_4-可应用回溯算法、贪心算法、分治算法、动态规划等解决复杂问题" tabindex="-1">4.可应用回溯算法、贪心算法、分治算法、动态规划等解决复杂问题 <a class="header-anchor" href="#_4-可应用回溯算法、贪心算法、分治算法、动态规划等解决复杂问题" aria-label="Permalink to &quot;4.可应用回溯算法、贪心算法、分治算法、动态规划等解决复杂问题&quot;">​</a></h2><h2 id="_5-前端处理海量数据的算法方案" tabindex="-1">5.前端处理海量数据的算法方案 <a class="header-anchor" href="#_5-前端处理海量数据的算法方案" aria-label="Permalink to &quot;5.前端处理海量数据的算法方案&quot;">​</a></h2><h1 id="五、运行环境" tabindex="-1">五、运行环境 <a class="header-anchor" href="#五、运行环境" aria-label="Permalink to &quot;五、运行环境&quot;">​</a></h1><h1 id="我们需要理清语言和环境的关系" tabindex="-1">我们需要理清语言和环境的关系： <a class="header-anchor" href="#我们需要理清语言和环境的关系" aria-label="Permalink to &quot;我们需要理清语言和环境的关系：&quot;">​</a></h1><p>ECMAScript描述了JavaScript语言的语法和基本对象规范 浏览器作为JavaScript的一种运行环境，为它提供了：文档对象模型（DOM），描述处理网页内容的方法和接口、浏览器对象模型（BOM），描述与浏览器进行交互的方法和接口 Node也是JavaScript的一种运行环境，为它提供了操作I/O、网络等API</p><h1 id="浏览器api" tabindex="-1">浏览器API <a class="header-anchor" href="#浏览器api" aria-label="Permalink to &quot;浏览器API&quot;">​</a></h1><h2 id="_1-浏览器提供的符合w3c标准的dom操作api、浏览器差异、兼容性" tabindex="-1">1.浏览器提供的符合W3C标准的DOM操作API、浏览器差异、兼容性 <a class="header-anchor" href="#_1-浏览器提供的符合w3c标准的dom操作api、浏览器差异、兼容性" aria-label="Permalink to &quot;1.浏览器提供的符合W3C标准的DOM操作API、浏览器差异、兼容性&quot;">​</a></h2><h2 id="_2-浏览器提供的浏览器对象模型-bom-提供的所有全局api、浏览器差异、兼容性" tabindex="-1">2.浏览器提供的浏览器对象模型 (BOM)提供的所有全局API、浏览器差异、兼容性 <a class="header-anchor" href="#_2-浏览器提供的浏览器对象模型-bom-提供的所有全局api、浏览器差异、兼容性" aria-label="Permalink to &quot;2.浏览器提供的浏览器对象模型 (BOM)提供的所有全局API、浏览器差异、兼容性&quot;">​</a></h2><h2 id="_3-大量dom操作、海量数据的性能优化-合并操作、diff、requestanimationframe等" tabindex="-1">3.大量DOM操作、海量数据的性能优化(合并操作、Diff、requestAnimationFrame等) <a class="header-anchor" href="#_3-大量dom操作、海量数据的性能优化-合并操作、diff、requestanimationframe等" aria-label="Permalink to &quot;3.大量DOM操作、海量数据的性能优化(合并操作、Diff、requestAnimationFrame等)&quot;">​</a></h2><h2 id="_4-浏览器海量数据存储、操作性能优化" tabindex="-1">4.浏览器海量数据存储、操作性能优化 <a class="header-anchor" href="#_4-浏览器海量数据存储、操作性能优化" aria-label="Permalink to &quot;4.浏览器海量数据存储、操作性能优化&quot;">​</a></h2><h2 id="_5-dom事件流的具体实现机制、不同浏览器的差异、事件代理" tabindex="-1">5.DOM事件流的具体实现机制、不同浏览器的差异、事件代理 <a class="header-anchor" href="#_5-dom事件流的具体实现机制、不同浏览器的差异、事件代理" aria-label="Permalink to &quot;5.DOM事件流的具体实现机制、不同浏览器的差异、事件代理&quot;">​</a></h2><h2 id="_6-前端发起网络请求的几种方式及其底层实现、可以手写原生ajax、fetch、可以熟练使用第三方库" tabindex="-1">6.前端发起网络请求的几种方式及其底层实现、可以手写原生ajax、fetch、可以熟练使用第三方库 <a class="header-anchor" href="#_6-前端发起网络请求的几种方式及其底层实现、可以手写原生ajax、fetch、可以熟练使用第三方库" aria-label="Permalink to &quot;6.前端发起网络请求的几种方式及其底层实现、可以手写原生ajax、fetch、可以熟练使用第三方库&quot;">​</a></h2><h2 id="_7-浏览器的同源策略-如何避免同源策略-几种方式的异同点以及如何选型" tabindex="-1">7.浏览器的同源策略，如何避免同源策略，几种方式的异同点以及如何选型 <a class="header-anchor" href="#_7-浏览器的同源策略-如何避免同源策略-几种方式的异同点以及如何选型" aria-label="Permalink to &quot;7.浏览器的同源策略，如何避免同源策略，几种方式的异同点以及如何选型&quot;">​</a></h2><h2 id="_8-浏览器提供的几种存储机制、优缺点、开发中正确的选择" tabindex="-1">8.浏览器提供的几种存储机制、优缺点、开发中正确的选择 <a class="header-anchor" href="#_8-浏览器提供的几种存储机制、优缺点、开发中正确的选择" aria-label="Permalink to &quot;8.浏览器提供的几种存储机制、优缺点、开发中正确的选择&quot;">​</a></h2><h2 id="_9-浏览器跨标签通信" tabindex="-1">9.浏览器跨标签通信 <a class="header-anchor" href="#_9-浏览器跨标签通信" aria-label="Permalink to &quot;9.浏览器跨标签通信&quot;">​</a></h2><h1 id="浏览器原理" tabindex="-1">浏览器原理 <a class="header-anchor" href="#浏览器原理" aria-label="Permalink to &quot;浏览器原理&quot;">​</a></h1><h2 id="_1-各浏览器使用的javascript引擎以及它们的异同点、如何在代码中进行区分" tabindex="-1">1.各浏览器使用的JavaScript引擎以及它们的异同点、如何在代码中进行区分 <a class="header-anchor" href="#_1-各浏览器使用的javascript引擎以及它们的异同点、如何在代码中进行区分" aria-label="Permalink to &quot;1.各浏览器使用的JavaScript引擎以及它们的异同点、如何在代码中进行区分&quot;">​</a></h2><h2 id="_2-请求数据到请求结束与服务器进行了几次交互" tabindex="-1">2.请求数据到请求结束与服务器进行了几次交互 <a class="header-anchor" href="#_2-请求数据到请求结束与服务器进行了几次交互" aria-label="Permalink to &quot;2.请求数据到请求结束与服务器进行了几次交互&quot;">​</a></h2><h2 id="_3-可详细描述浏览器从输入url到页面展现的详细过程" tabindex="-1">3.可详细描述浏览器从输入URL到页面展现的详细过程 <a class="header-anchor" href="#_3-可详细描述浏览器从输入url到页面展现的详细过程" aria-label="Permalink to &quot;3.可详细描述浏览器从输入URL到页面展现的详细过程&quot;">​</a></h2><h2 id="_4-浏览器解析html代码的原理-以及构建dom树的流程" tabindex="-1">4.浏览器解析HTML代码的原理，以及构建DOM树的流程 <a class="header-anchor" href="#_4-浏览器解析html代码的原理-以及构建dom树的流程" aria-label="Permalink to &quot;4.浏览器解析HTML代码的原理，以及构建DOM树的流程&quot;">​</a></h2><h2 id="_5-浏览器如何解析css规则-并将其应用到dom树上" tabindex="-1">5.浏览器如何解析CSS规则，并将其应用到DOM树上 <a class="header-anchor" href="#_5-浏览器如何解析css规则-并将其应用到dom树上" aria-label="Permalink to &quot;5.浏览器如何解析CSS规则，并将其应用到DOM树上&quot;">​</a></h2><h2 id="_6-浏览器如何将解析好的带有样式的dom树进行绘制" tabindex="-1">6.浏览器如何将解析好的带有样式的DOM树进行绘制 <a class="header-anchor" href="#_6-浏览器如何将解析好的带有样式的dom树进行绘制" aria-label="Permalink to &quot;6.浏览器如何将解析好的带有样式的DOM树进行绘制&quot;">​</a></h2><h2 id="_7-浏览器的运行机制-如何配置资源异步同步加载" tabindex="-1">7.浏览器的运行机制，如何配置资源异步同步加载 <a class="header-anchor" href="#_7-浏览器的运行机制-如何配置资源异步同步加载" aria-label="Permalink to &quot;7.浏览器的运行机制，如何配置资源异步同步加载&quot;">​</a></h2><h2 id="_8-浏览器回流与重绘的底层原理-引发原因-如何有效避免" tabindex="-1">8.浏览器回流与重绘的底层原理，引发原因，如何有效避免 <a class="header-anchor" href="#_8-浏览器回流与重绘的底层原理-引发原因-如何有效避免" aria-label="Permalink to &quot;8.浏览器回流与重绘的底层原理，引发原因，如何有效避免&quot;">​</a></h2><h2 id="_9-浏览器的垃圾回收机制-如何避免内存泄漏" tabindex="-1">9.浏览器的垃圾回收机制，如何避免内存泄漏 <a class="header-anchor" href="#_9-浏览器的垃圾回收机制-如何避免内存泄漏" aria-label="Permalink to &quot;9.浏览器的垃圾回收机制，如何避免内存泄漏&quot;">​</a></h2><h2 id="_10-浏览器采用的缓存方案-如何选择和控制合适的缓存方案" tabindex="-1">10.浏览器采用的缓存方案，如何选择和控制合适的缓存方案 <a class="header-anchor" href="#_10-浏览器采用的缓存方案-如何选择和控制合适的缓存方案" aria-label="Permalink to &quot;10.浏览器采用的缓存方案，如何选择和控制合适的缓存方案&quot;">​</a></h2><h1 id="node" tabindex="-1">Node <a class="header-anchor" href="#node" aria-label="Permalink to &quot;Node&quot;">​</a></h1><h2 id="_1-理解node在应用程序中的作用-可以使用node搭建前端运行环境、使用node操作文件、操作数据库等等" tabindex="-1">1.理解Node在应用程序中的作用，可以使用Node搭建前端运行环境、使用Node操作文件、操作数据库等等 <a class="header-anchor" href="#_1-理解node在应用程序中的作用-可以使用node搭建前端运行环境、使用node操作文件、操作数据库等等" aria-label="Permalink to &quot;1.理解Node在应用程序中的作用，可以使用Node搭建前端运行环境、使用Node操作文件、操作数据库等等&quot;">​</a></h2><h2 id="_2-掌握一种node开发框架-如express-express和koa的区别" tabindex="-1">2.掌握一种Node开发框架，如Express，Express和Koa的区别 <a class="header-anchor" href="#_2-掌握一种node开发框架-如express-express和koa的区别" aria-label="Permalink to &quot;2.掌握一种Node开发框架，如Express，Express和Koa的区别&quot;">​</a></h2><h2 id="_3-熟练使用node提供的api如path、http、child-process等并理解其实现原理" tabindex="-1">3.熟练使用Node提供的API如Path、Http、Child Process等并理解其实现原理 <a class="header-anchor" href="#_3-熟练使用node提供的api如path、http、child-process等并理解其实现原理" aria-label="Permalink to &quot;3.熟练使用Node提供的API如Path、Http、Child Process等并理解其实现原理&quot;">​</a></h2><h2 id="_4-node的底层运行原理、和浏览器的异同" tabindex="-1">4.Node的底层运行原理、和浏览器的异同 <a class="header-anchor" href="#_4-node的底层运行原理、和浏览器的异同" aria-label="Permalink to &quot;4.Node的底层运行原理、和浏览器的异同&quot;">​</a></h2><h2 id="_5-node事件驱动、非阻塞机制的实现原理" tabindex="-1">5.Node事件驱动、非阻塞机制的实现原理 <a class="header-anchor" href="#_5-node事件驱动、非阻塞机制的实现原理" aria-label="Permalink to &quot;5.Node事件驱动、非阻塞机制的实现原理&quot;">​</a></h2><h1 id="数据结构和算法-1" tabindex="-1">数据结构和算法 <a class="header-anchor" href="#数据结构和算法-1" aria-label="Permalink to &quot;数据结构和算法&quot;">​</a></h1><ul><li>数据结构与算法之美：time.geekbang.org/colum</li><li>用动画的形式呈现解LeetCode题目的思路：github.com/MisterBooo/L</li><li>JavaScript数据结构和算法：github.com/ConardLi/awe</li><li>30-seconds-of-code（里面有很多js代码非常巧妙，我正在将它翻译成中文）：github.com/ConardLi/30-</li></ul><h1 id="运行环境" tabindex="-1">运行环境 <a class="header-anchor" href="#运行环境" aria-label="Permalink to &quot;运行环境&quot;">​</a></h1><ul><li>《重学前端》中的浏览器原理章节：time.geekbang.org/colum</li><li>图解浏览器的基本工作原理：zhuanlan.zhihu.com/p/47</li><li>七天学会NodeJS：github.com/nqdeng/7-day</li><li>Node.js模块加载与运行原理：efe.baidu.com/blog/node</li></ul>`,62),r=[t];function l(n,o,d,k,p,c){return e(),i("div",null,r)}const q=a(h,[["render",l]]);export{b as __pageData,q as default};
