import{_ as l,c as e,o as i,a1 as t}from"./chunks/framework.DDqzfET5.js";const _=JSON.parse('{"title":"vue","description":"","frontmatter":{},"headers":[],"relativePath":"框架和类库/Vue/index.md","filePath":"框架和类库/Vue/index.md"}'),a={name:"框架和类库/Vue/index.md"},o=t('<h1 id="vue" tabindex="-1">vue <a class="header-anchor" href="#vue" aria-label="Permalink to &quot;vue&quot;">​</a></h1><h2 id="_1-生命周期函数" tabindex="-1">1. 生命周期函数 <a class="header-anchor" href="#_1-生命周期函数" aria-label="Permalink to &quot;1. 生命周期函数&quot;">​</a></h2><ol><li>基础</li></ol><ul><li>初始化阶段 <ul><li>beforeCreate</li><li>created</li></ul></li><li>挂载阶段 <ul><li>beforeMount</li><li>mounted</li></ul></li><li>更新阶段 <ul><li>beforeUpdate</li><li>updated</li></ul></li><li>卸载阶段 <ul><li>Vue2: beforeDestroy / destroyed</li><li>Vue3: beforeUnmount / unmounted</li></ul></li></ul><ol start="2"><li>重要的生命周期</li></ol><p>其中重要生命周期：mounted 和 beforeDestroy（beforeUnmount）</p><ul><li>mounted 用来发送请求、设置定时器、绑定事件等任务</li><li>beforeDestroy 用来解绑定时器，解绑事件等收尾工作，防止内存泄漏</li></ul><ol start="3"><li>其他生命周期函数</li></ol><p>除此之外，还有一些别的生命周期函数：</p><ul><li><p>被 keep-alive 缓存的组件会自动拥有两个生命周期函数</p><ul><li>activated</li><li>deactivated</li></ul></li><li><p>用来捕获后代组件产生的错误</p><ul><li>errorCaptured</li></ul></li></ul><ol start="4"><li>Vue3 提供了两种开发模式：选项式和组合式，其中组合式 API 生命周期用法有一些变化</li></ol><ul><li>setup：相当于之前的 beforeCreate/created</li><li>剩下的生命周期函数需要引入使用，比如： <ul><li>onMounted</li><li>onBeforeUnmount</li></ul></li><li>每个生命周期函数都能使用多次</li></ul><h2 id="_2-组件间通信" tabindex="-1">2. 组件间通信 <a class="header-anchor" href="#_2-组件间通信" aria-label="Permalink to &quot;2. 组件间通信&quot;">​</a></h2><ol><li>props 父 -&gt; 子</li></ol><p>可以展开说说 props 具体内容</p><ol start="2"><li>自定义事件 子 -&gt; 父</li></ol><ul><li>Vue2 中给组件绑定的事件默认都是自定义事件，加上<code>.native</code>才是 DOM 事件</li><li>Vue3 中给组件绑定的事件默认是 DOM 事件（当然实际要满足条件才会绑定：1. 事件名需要是 DOM 事件名称 2. 子组件必须有根标签 3. 子组件内部不能 defineEmits 声明接受），不满足条件就是自定义事件</li></ul><ol start="3"><li>v-model 父 &lt;-&gt; 子</li></ol><p>vue2 和 vue3 用法也不一样：</p><ul><li>vue2 中给组件绑定 value 属性和 input 自定义事件</li><li>vue3 中默认给组件绑定 modelValue 属性和 update:modelValue 事件 <ul><li>也可以通过 v-model:xxx 的方式修改属性名和事件名</li></ul></li></ul><ol start="4"><li>v-bind:xxx.sync 父 &lt;-&gt; 子</li></ol><ul><li>只有 vue2 才能使用，vue3 不能使用了</li><li>绑定 xxx 属性和 update:xxx 自定义事件</li></ul><ol start="5"><li>插槽 父 &lt;-&gt; 子</li></ol><ul><li>通信的内容主要是标签数据（之前通信方案都是普通数据）</li><li>分类：默认插槽、具名插槽和作用域插槽</li><li>一般我设置组件时，会优先最重要内容用默认插槽（因为简单），其他内容考虑具名插槽，如果需要子向父通信用作用域插槽（table）</li></ul><ol start="6"><li>vuex / pinia 兄弟、祖孙</li></ol><ul><li>一般 vue2 项目用 vuex，vue3 项目用 pinia</li></ul><ol start="7"><li>还有其他通信方案</li></ol><ul><li>全局事件总线(兄弟)：vue2 中能使用，vue3 不能使用了, 因为删除了<code>$on/$off</code>等自定义事件方法，想要使用必须用第三方库，比如 mitt 实现</li><li><code>$parent/$children/$refs</code>（父 &lt;-&gt; 子），其中 vue3 删除了<code>$children</code></li><li><code>$attrs/$listeners</code> （父 -&gt; 子）, 其中 vue3 删除了<code>$listeners</code>， 内容放入了<code>$attrs</code>中</li><li>provide/inject 祖孙</li></ul><h2 id="_3-谈谈-vuex" tabindex="-1">3. 谈谈 Vuex <a class="header-anchor" href="#_3-谈谈-vuex" aria-label="Permalink to &quot;3. 谈谈 Vuex&quot;">​</a></h2><p>一个集中式状态管理方案，通常用于管理多个组件共享的状态数据。</p><p>开发时需要定义主模块和其他分模块</p><p>主模块主要定义 modules 属性用来汇总其他分模块</p><p>其他分模块主要定义 state、getters、actions、mutations、namespaced。</p><ul><li>state 模块管理的状态数据</li><li>getters 只读计算属性数据</li><li>actions 一般用来与服务器进行交互的函数，比如：发送请求</li><li>mutations 直接更新数据的函数</li><li>namespaced 的值为 true，开启命名空间，这样每个 vuex 模块的内容就被隔离，不会互相影响。</li></ul><p>组件读取/更新 vuex 数据有两种方式，一种通过<code>$store</code>，一种 map 函数形式</p><p>一般如果数据只用一两次，我会用$store，比较简单。数据比较频繁使用，用 map 函数形式</p><h2 id="_4-谈谈-pinia" tabindex="-1">4. 谈谈 Pinia <a class="header-anchor" href="#_4-谈谈-pinia" aria-label="Permalink to &quot;4. 谈谈 Pinia&quot;">​</a></h2><p>一个集中式状态管理方案，通常用于管理多个组件共享的状态数据。</p><p>相对于 Vuex 来说，pinia 优点：</p><ul><li>没有 mutations （流程更简洁）</li><li>Typescript 支持更友好</li><li>pinia 模块定义即可使用，不用汇总</li></ul><p>开发时需要定义主模块和其他分模块：主模块定义好后，就定义分模块即可，不用汇总</p><p>分模块主要由以下内容：</p><ul><li>state 模块管理的状态数据</li><li>getters 只读计算属性数据</li><li>actions 与服务器进行交互（发送请求），同时更新数据</li></ul><p>组件引入分模块暴露的 useXxxStore 函数，得到 Store 对象，即可操作数据和方法了</p><ul><li>一般如果我需要直接更新一个数据：就直接操作数据即可</li><li>如果我需要直接更新多个数据：store.$patch 方法更新数据</li><li>如果我需要更新数据并且发送请求：就需要定义 action 函数，通过 store 调用 action 函数来更新</li></ul>',45),u=[o];function r(n,d,s,p,c,m){return i(),e("div",null,u)}const h=l(a,[["render",r]]);export{_ as __pageData,h as default};
